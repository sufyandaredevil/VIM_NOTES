----------------------------------------------------------------------------
INTRODUCTION TO VIM
----------------------------------------------------------------------------

VIM - Vi IMproved where Vi means 'Visual'
the cmd vi has been replaced by vim but still both could be used
Vim is available in a TUI(Textbased user interface) and a GUI 

----------------------------------------------------------------------------
MODES IN VIM
----------------------------------------------------------------------------

normal/command mode (Esc|<C-[>) - normally vim starts in this mode (usually used for entering commands)
insert mode (i) - mode for inserting text
commandline/line modes(:,?,/,!) - normally entered when in normal mode that enables to enter cmd like saving, searching, locating, switching options related to vim etc
visual modes - used for selecting text 
    v{motion} - starts text selection continued with next motion
    V{motion} - for line selection continued with next motion
    <C-v>{motion} (NOTE: <C-v> means pressing [CTRL] + v) - means block selection of text continued with next motion)

----------------------------------------------------------------------------
NAVIGATION CMDS IN VIM
----------------------------------------------------------------------------

j - move down
k - move up
l - move right
h - move left

w - move to next word (considers punctuation as a word and whitespace)
b - move to previous word (considers punctuation as a word and whitespace)
W - move to next word (doesn't consider punctuation as a word) considering whitespace
B - move to previous word (doesn't consider punctuation as a word) considering whitespace

0 - jump to the beginning of the line
$ - jump to the end of the line
^ - jump to very first character(not a whitespace) in the line

gg - jumps to first line in the file
G - jumps to last line in the file

:<line_number> - jump to given line_number in the file
:$ - jump to the end of the file

(NOTE: <C-any_alphabet> means [CTRL] + any_alphabet, <CR> means [ENTER])
<C-f> - Page Down
<C-b> - Page Up
<C-o> - Move Cursor to previous position, i.e. from where the cursor is jumped from
<C-i> - Move Cursor to lastly changed position, i.e. to the very last position where cursor was placed
<C-]> - Move Cursor to the highlighted text's definition below cursor(this only works within vim's :help <command> context or help.txt file). For more view HELP SYSTEM IN VIM Section
<C-w><C-w> - Switch between files in vim
z<CR> - moves the current cursor's position up on the screen

    |--------(following block to be replaced elsewhere later due to not being navigation cmds)----------------------
    |  <C-g> - displays file's name, metadata, status, current & total line, cursor's position in the current file, how far we're down a file(in %), column number where cursor is at
    |  g<C-g> - displays even more metadata that the above cmd
    |  
    |  (following set of commands follow a pattern that's used throughout in vim, i.e. --> :set <cmd>|no<cmd> to enable/disable an option or --> :set <cmd>! to toggle that option on/off and :set <cmd>? to check whether cmd set/not In the following case cmd is 'ruler')
    |  :set ruler - shows line and column number in lower bottom side of vim(after set few <C-g> info is hidden to avoid metadata redundancy)
    |  :set noruler - hides line and column number in lower bottom side of vim
    |  :set ruler! - toggles line and column number in lower bottom side of vim
    |  :set ruler? - shows whether the ruler is set/not i.e. outputs ruler/noruler if set/reset
    |  
    |  . - repeats previous command
    |  u - undo previous change
    |  <C-r> - redo previous change
    |  
    |  :w - saves the current file
    |  :wq - write and quit
    |  :q - quit if no changes are done and if changed, warning is shown
    |  :q! - quit without write
    |  NOTE: the symbol ! when used in command/line mode(:) generally means to force an action, toggle setting, execute external cmd etc
    |  
    |  i - goto insert mode(i.e. before the cursor)
    |  I - goto 0th position in current cursor's line and goto insert mode
    |  a - goto insert mode(i.e. after the cursor)
    |  A - goto $th position in current cursor's line and goto insert mode
    |  O - Insert new line below the cursor and enter insert mode
    |  o - Insert new line above the cursor and enter insert mode
    |  for repetition of text insertion:
    |  
    |  [count] [above_cmds] <your_text_here> <Esc>
    |  Eg: 5i*<Esc> - places '*' 5 times horizontally
    |  Eg: 5o*<Esc> - places '*' 5 times vertically
    |  
    |---------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------
TEXT DELETION CMDS IN VIM
----------------------------------------------------------------------------

NOTE: foll. commands basically cuts and saves deleted content to register. For more see --> CUT COPY PASTE (DELETE,YANK,PUT) IN VIM Section

x - delete letter present below the cursor
X - delete letter present before the cursor
D - deletes texts from current cursor's position to end of the line
d<motion_cmd> - delete texts from current cursor's position upto given <motion_cmd>
Eg: dw - deletes a word from the cursor's current position
<count>dd<motion_cmd> - delete current line and contents where cursor is <count> times upto given motion
Eg: 5dw - delete 5 words
NOTE: the above 2 cmds generally means: [count]operation{motion}. Also --> [count]operation[count]{motion} is possible

----------------------------------------------------------------------------
HELP SYSTEM IN VIM
----------------------------------------------------------------------------

:help - opens the vim's help.txt(in readonly mode) which is a text file, where if we press <C-g> we can see the location of where the file help.txt is located
:help <command> - shows info about the <command> given from the help.txt file
Eg: :help dd

NOTE: when we see infos present within square brackets ([]) always know that they are optional
i.e. for the above example the description we see will be "Delete [count] lines [into register x] linewise.", where count and into register x are optional to be considered
We can also get help on other various subjects and this is identified by the color when help.txt is viewed in vim.
Eg: for the optional subject we saw previously ([count] which is highlighted in purple(color might vary)) can also be viewed in the help as follows:
:help count
We can also go to the definition of a highlighted word like count, linewise but keeping the cursor over it and press <C-]>

Other Important Examples:

    1 - :help :q
    NOTE: for the above definition we see that from ':q[uit]', 'uit' is placed inside [] brackets which means they are optional to type i.e. :q | :quit, both means the same

    2 - :h Ctrl-f|^f - help description for cmds with CTRL button presses. Here ^ can be used instead of typing 'Ctrl-'

    3 - :help :help
    NOTE: even for the above definition the words elp from help are optional to type i.e. :help | :h, both means the same

Also when typing :h | :help <cmd>, when we wanna see all different combinations of entered <cmd>(similar to auto suggest) we can type:
:h :q[PRESS CTRL + d now], which shows all possibilities of q i.e. :q, :quit, :quita, :qa etc., also:
:h :q[PRESS TAB BUTTON now], which does the same as above but we can select using enterkey from the possibilities shown, and SHIFT + TAB reverses the possibility traversing

Help system is also useful to know alternatives for a known command
Eg: :f can be used instead of using <C-g> which can be found from the help.txt documentation after we searching using :h ^g

----------------------------------------------------------------------------
CUT COPY PASTE (DELETE,YANK,PUT) IN VIM
----------------------------------------------------------------------------

NOTE: we've seen cmds like d,D,x in TEXT DELETION CMDS, but both actually cut text and not just delete it
where cut = delete and save into a register (register is a clipboard-like storage location for vim)

D - cut text from cursor till end and place in the UNNAMED/DEFAULT register
dd - cut line and place in the UNNAMED/DEFAULT register
x - cut text and place in the UNNAMED/DEFAULT register
P - put text before the cursor
p - put text after the cursor
y{motion} - yank text wrt given motion
yy - yanks whole line's content present below cursor

----------------------------------------------------------------------------
REGISTERS IN VIM
----------------------------------------------------------------------------

Types of Registers:
    UNNAMED/DEFAULT = "" (holds text from d,c,s,x,y ops/contains last operated on text)
    NUMBERED = "0, "1,..., "9 (generally contents in these registers shift with each d or c ops)
        ("0 holds last text yanked(y))
        ("1 holds last text deleted(d) or changed(c))
    NAMED = "a, "b,..., "z (totally controlled by user also "A,..., "Z can also be used but "a & "A mean the same.
        NOTE: in context to commands when used with capital alphabets (i.e. uppercase named register) contents are appended instead of being replaced or created)
        Eg: copying something to "a and again copying something would mess up the older content so we can use "A instead of "a that in result appends the content 
    BLACKHOLE = "_ (usually used when we don't wanna mess up the numbered register's content while performing vim ops)


To view specific/all register/s --> :reg [register(s)]
Eg--> :reg - view all register's contents
Eg--> :reg 1z - view register 1 and register z's contents
Eg--> :reg " - view default register's content

To delete a line without changing the contents in the register --> "_dd

To put/paste content from a register --> "<register_type_specific><put_cmd>
Eg: "0P - put text from register 0 to the current file
NOTE: same goes for copying content to a specific type of register.
Eg: "ayy - yank whole line's content below the cursor to register a

To perform repetition with registers --> [count][register]command | [register][count]command
Eg:  2"hp | "h2p - paste(p) content from h register("h) twice(2)

----------------------------------------------------------------------------
TEXT TRANSFORMATION IN VIM
----------------------------------------------------------------------------

R - replaces text present below the cursor and beyond then stays in replace mode
r - replace only one text present below the cursor then goes to normal mode automatically

[count]cc - deletes/cuts whole [count] line's content and stays in insert mode
c<motion_cmd> - deletes/cuts from current cursor's position till given motion and stays in insert mode
Eg--> cw - change a word and stay in insert mode (alternative to cmd 'dwi' but space present after the word would be removed in this case)
C - delete/cuts from current cursor's position till end of current line and stays in insert mode
NOTE: C is an alternative to the cmd 'd$a'

~ - Toggles a single alphabet's case present under the cursor
g~<motion> - Toggles alphabet's case present under the cursor till given motion
Eg--> g~w - toggles case of the word present under the cursor
g~~ - Toggles all alphabets case in the current cursor's line (alternative to g~$)
gU<motion> - Force toggle alphabets to uppercase under the cursor till given motion
gUU - Force toggle all alphabets to uppercase present under the cursor's line
gu<motion> - Force toggle alphabets to lowercase under the cursor till given motion
guu - Force toggle all alphabets to lowercase present under the cursor's line

[count]J - joins succeeding line to the current cursor's line by adding a space (if not present already) and repeats this [count] times
[count]gJ - same as above put doesn't include the spacing logic in this one and repeats this [count] times

----------------------------------------------------------------------------
SEARCH/FIND,REPLACE/SUBSTITUTION IN VIM
----------------------------------------------------------------------------

f<character_you're_searching_for> - forward search in cursor's line and places the cursor on the character you searched for
F<character_you're_searching_for> - backward search in cursor's line and places the cursor on the character you searched for
t<character_you're_searching_for> - forward search in cursor's line and places the cursor before the character you searched for
T<character_you're_searching_for> - backward search in cursor's line and places the cursor after the character you searched for
    ; - forward cycle(for f,t)/backward cycle(for F,T) through found searches
    , - backward cycle(for f,t)/forward cycle(for F,T) through found searches

NOTE: [count] could also be mentioned with f,F,t,T. Eg --> 2f<character_you're_searching_for> - goto 2nd search result of the character you searched for

To delete from current cursor's position uptill given searched text in the same line --> dt<the_character_uptill_you_wanna_delete>
To delete from current cursor's position upto given searched text in the same line --> df<the_character_upto_you_wanna_delete>
Eg: if 'Hello world' is the string then:
    'dtw' deletes 'Hello '
    'dfw' deletes 'Hello w'

/<text_you're_searching_for> - forward search whole file
?<text_you're_searching_for> - backward search whole file
* - forward search for the next occurence of the entire word only that's under the cursor
# - backward search for the previous occurence of the entire word only that's under the cursor
    n - forward cycle(for /,*)/backward cycle(for ?,#) through found searches
    N - backward cycle(for /,*)/forward cycle(for ?,#) through found searches

To delete from current cursor's position uptill given searched text --> d/<the_text_uptill_you_wanna_delete>
To yank text from current cursor's position uptill given searched text into a register --> "<register>y/<the_text_uptill_you_wanna_delete>

Options available related to searching:
:set is! | incsearch! - to toggle incremental search, i.e. constantly places the cursor in the text you search and keep incrementing the placement until you're done typing your search keyword
:set hls! | hlsearch! - to toggle search highlighting 
:set nu! | number! - to toggle number line

For Text Substitution:
:[range]s/{old_text}/{new_text}/[flags] - substitutes old_text to new_text for given range(can be a number n or n,m) wrt given flags
NOTE: the [flags] 'g' is applied per line when a range is given

special [range]s could be as follows:
. - current line
$ - last line in the file
% - All lines (entire file, i.e. alternative to 1,$)
/<PATTERN-1>/,/<PATTERN-2>/ - <PATTERN-1>, <PATTERN-2> are text that can be given as a scope for substitution

Important Examples:

Eg--> :s/The/A/ - substitute occurence of 'The' to 'A' in the current cursor's line only
Eg--> :1s/The/A/g - substitute all occurences of 'The' to 'A' in the 1st line only
Eg--> :1,5s/The/A/g - substitute all occurences of 'The' to 'A' from the 1st to 5th line
Eg--> :%s/The/A/g - substitute all occurences of 'The' to 'A' from the entire file
Eg--> :.,$s/The/A/g - substitute all occurences of 'The' to 'A' from the current line to the last line in the file
Eg--> :/Start/,/End/s/The/A/g - substitute all occurences of 'The' to 'A' only within the given pattern 'Start' to 'End'
Eg--> :/Start/,$s/The/A/g - substitute all occurences of 'The' to 'A' from the given pattern 'Start' to the last line in the file

If there are forward slashes within the text itself we need to escape them while substituting
Eg: if the given text /var/spool has to be replaced with /usr/local we do the following:
--> :s/\/var\/spool/\/usr\/local/
Or there's an alternative method where we can change the pattern separator as follows:
--> :s#/var/spool#/usr/local#

----------------------------------------------------------------------------
TEXT OBJECTS IN VIM
----------------------------------------------------------------------------

NOTE:
a - includes delimiter / around / a
i - doesn't includes delimiter / inner

general form of creating a text object cmd:
[register(s)]{operation}{a|i}{motion|text_object}
Here operation could be d,c,g,y etc
text_object could be >,<,{,},[,],",' etc
motion could be y,w,c etc

aw - a word with the operation performed
iw - inner word with the operation performed
Eg--> daw, diw

as - a sentence with the operation performed (.,!,? is the separator)
is - inner sentence with the operation performed
Eg--> das, dis

ap - a paragraph with the operation performed(newline is the separator)
ip - inner paragraph with the operation performed
Eg--> dap, dip

To illustrate the usage of above cmds consider 'Hello World! how are you?' where we want to delete the word 'Hello'
if we perform 'dw' by placing the cursor above the first 'l' in 'Hello' we get the output: 'He World! How are you?'
but in case of 'daw' if we place the cursor anywhere but above the word 'Hello' we get the output: 'World! How are you?'
which means that Text Objects doesn't consider the place where we place our cursor but we only need to place the cursor with the motion's context i.e. if we are operating a word we need to stay above the word atleast/in case of a bracket within the scope bracket atleast

Important Examples for Text objects (Programming):

Eg: colors = ['red', 'green', 'blue']
To delete values inside [] and stay in insert mode:
--> ci[ | ci]
And to delete the brackets also:
--> da[ | da]
NOTE: same goes for <> (angular brackets) i.e. ci< | ci>' & da< | da>

Eg: print(colors)
To delete the variable within () and stay in insert mode:
--> ci( | ci) or --> cib | cib
And to delete the parenthesis also:
--> da( | da) or --> dab | dab
NOTE: same goes for {} (curly brackets) i.e. ci{ | ci}' or ciB | ciB & da{ | da} or daB | daB

Eg: NAME = "VIM"
To delete values within "" and stay in insert mode:
--> ci"
And to delete the 2 doubt quotes also:
--> da"
NOTE: same goes for ' & ` (single quote & backtick) i.e. ci' | da' & ci` | da`

Eg: <p>This is a <b>new</b> tag </p>
To delete the content present within the paragraph tag (<p> THESE_ONES </p>) and stay in insert mode:
--> cit
And to delete the angular brackets also:
--> dat
NOTE: in this example there is a nested tag(<b>new</b>) so to perform text manips. atleast place the cursor at the start of the angular bracket(OVER HERE --><b>new</b>)
Same goes for nested [],{},"" etc

----------------------------------------------------------------------------
MACROS IN VIM
----------------------------------------------------------------------------

q{register}<all_your_cmds> - to start recording and store the vim routine/macro in a register
q - to stop recording and vim routine/macro'll be saved in the particular register you mentioned while starting the recording 
[count]@{register} - replay the recorded macro from the register [count] times
:[range(s)] normal @{register} - replay the recorded macro from the register for the given range only. For more about ranges view Text Substitution in SEARCH/FIND,REPLACE/SUBSTITUTION IN VIM Section
[count]@@ - repeat most recently executed macro [count] times

NOTE: use the capital alphabets to append macros if missed while recording at start

Macro Best Practices:
    Normalize the cursor position (0)
    Perform edits & ops
    Position your cursor to enable easy replays (j)

Saving Macros:
.viminfo(linux,MAC) / _viminfo(windows) present in ~ dir.
.vimrc(linux,MAC) / _vimrc(windows) present in ~ dir. (File that contains initialization commands)

To create macros in vimrc file:
let @<register_name> = '<key_strokes>'
Eg-->let @<register_name> = 'ITODO: ^[j'
NOTE: to create the <Esc> we need to create a literal i.e. press [CTRL] + v in normal mode that creates ^ as a literal and then press [ESC]
